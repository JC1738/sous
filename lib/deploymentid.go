package sous

import (
	"crypto/md5"
	"fmt"
	"io"
	"strings"

	"github.com/opentable/sous/util/logging"
)

// A DeploymentID identifies a deployment.
type DeploymentID struct {
	ManifestID ManifestID
	Cluster    string
}

// ParseDeploymentID parses a DeploymentID from s.
// The string provided must be in the same format as emitted by
// DeploymentID.String.
func ParseDeploymentID(s string) (DeploymentID, error) {
	if s == "" {
		return DeploymentID{}, fmt.Errorf("empty string not valid")
	}
	clusterManifest := strings.SplitN(s, ":", 2)
	if len(clusterManifest) != 2 {
		return DeploymentID{}, fmt.Errorf("does not contain a colon")
	}
	cluster := clusterManifest[0]
	manifestID, err := ParseManifestID(clusterManifest[1])
	if err != nil {
		return DeploymentID{}, err
	}
	return DeploymentID{
		Cluster:    cluster,
		ManifestID: manifestID,
	}, nil
}

// Digest genrates an MD5 sum generated by the combination of  Git repo,
// project flavor, and the name of the cluster separted by null bytes.
func (did *DeploymentID) Digest() []byte {
	h := md5.New()
	sep := []byte{0}
	io.WriteString(h, did.ManifestID.Source.String())
	h.Write(sep)
	io.WriteString(h, did.ManifestID.Flavor)
	h.Write(sep)
	io.WriteString(h, did.Cluster)

	return h.Sum(nil)
}

func (did DeploymentID) String() string {
	return did.Cluster + ":" + did.ManifestID.String()
}

// QueryMap returns a map suitable to use as an HTTP get parameter map to idenitfy a deployment.
func (did DeploymentID) QueryMap() map[string]string {
	deployQuery := map[string]string{}
	deployQuery["repo"] = did.ManifestID.Source.Repo
	deployQuery["cluster"] = did.Cluster
	deployQuery["offset"] = did.ManifestID.Source.Dir
	deployQuery["flavor"] = did.ManifestID.Flavor
	return deployQuery
}

// EachField implements logging.EachFielder on DeploymentID.
func (did DeploymentID) EachField(fn logging.FieldReportFn) {
	fn(logging.SousDeploymentId, did.String())
	did.ManifestID.EachField(fn)
}
